<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"luohuayong.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="笔记 Whoosh 3.0 中用于排序和分面的 API 发生了变化。  概述Whoosh 中的排序和分面搜索结果是基于分面的。 每个方面都将一个值与搜索结果中的每个文档相关联，允许你按键排序或使用它们对文档进行分组。 Whoosh 包含多种可用于排序和分组的方面类型（见下文）。">
<meta property="og:type" content="article">
<meta property="og:title" content="Whoosh 14 - 排序和分面 (faceting)">
<meta property="og:url" content="https://luohuayong.github.io/whoosh/14-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%9D%A2%20(faceting)/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="笔记 Whoosh 3.0 中用于排序和分面的 API 发生了变化。  概述Whoosh 中的排序和分面搜索结果是基于分面的。 每个方面都将一个值与搜索结果中的每个文档相关联，允许你按键排序或使用它们对文档进行分组。 Whoosh 包含多种可用于排序和分组的方面类型（见下文）。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-20T13:38:02.698Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="Whoosh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://luohuayong.github.io/whoosh/14-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%9D%A2%20(faceting)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://luohuayong.github.io/whoosh/14-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%9D%A2%20(faceting)/","path":"whoosh/14-排序和分面 (faceting)/","title":"Whoosh 14 - 排序和分面 (faceting)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Whoosh 14 - 排序和分面 (faceting) | 技术博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">技术博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E5%AD%97%E6%AE%B5%E5%8F%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">使字段可排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">关于列类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-COLUMN-%E5%AD%97%E6%AE%B5%E4%BD%9C%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E9%94%AE"><span class="nav-number">3.</span> <span class="nav-text">使用 COLUMN 字段作为自定义排序键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%8E%B0%E6%9C%89%E5%AD%97%E6%AE%B5%E5%8F%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">3.1.</span> <span class="nav-text">使现有字段可排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">3.2.</span> <span class="nav-text">排序搜索结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">3.3.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%88%97%E5%80%BC"><span class="nav-number">3.4.</span> <span class="nav-text">访问列值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84"><span class="nav-number">3.5.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#groupedby-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">groupedby 关键字参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="nav-number">3.7.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%86%E9%9D%A2%E7%BB%84"><span class="nav-number">3.8.</span> <span class="nav-text">获取分面组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%BB%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.9.</span> <span class="nav-text">刻面类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E9%9D%A2"><span class="nav-number">3.10.</span> <span class="nav-text">场面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%9D%A2"><span class="nav-number">3.11.</span> <span class="nav-text">查询面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E9%9D%A2"><span class="nav-number">3.12.</span> <span class="nav-text">范围面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E8%8C%83%E5%9B%B4%E9%9D%A2"><span class="nav-number">3.13.</span> <span class="nav-text">日期范围面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%95%B0%E9%9D%A2"><span class="nav-number">3.14.</span> <span class="nav-text">分数面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E9%9D%A2"><span class="nav-number">3.15.</span> <span class="nav-text">功能面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StoredFieldFacet"><span class="nav-number">3.16.</span> <span class="nav-text">StoredFieldFacet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%96%B9%E9%9D%A2"><span class="nav-number">3.17.</span> <span class="nav-text">多方面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC"><span class="nav-number">3.18.</span> <span class="nav-text">缺失值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%87%8D%E5%8F%A0%E7%BB%84"><span class="nav-number">3.19.</span> <span class="nav-text">使用重叠组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">使用自定义排序顺序</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luohuayong.github.io/whoosh/14-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%9D%A2%20(faceting)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Whoosh 14 - 排序和分面 (faceting) | 技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Whoosh 14 - 排序和分面 (faceting)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-06-20 00:00:00 / 修改时间：21:38:02" itemprop="dateCreated datePublished" datetime="2023-06-20T00:00:00+08:00">2023-06-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>笔记</p>
<p>Whoosh 3.0 中用于排序和分面的 API 发生了变化。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Whoosh 中的排序和分面搜索结果是基于分面的。 每个方面都将一个值与搜索结果中的每个文档相关联，允许你按键排序或使用它们对文档进行分组。 Whoosh 包含多种可用于排序和分组的方面类型（见下文）。</p>
<span id="more"></span>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>默认情况下，搜索结果首先按照得分最高的文档排序。 你可以使用 sortedby 关键字参数来按其他一些标准对结果进行排序，例如字段的值。</p>
<h3 id="使字段可排序"><a href="#使字段可排序" class="headerlink" title="使字段可排序"></a>使字段可排序</h3><p>为了对字段进行排序，你应该使用 sortable&#x3D;True 关键字参数创建字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(title=fields.TEXT(sortable=<span class="literal">True</span>),</span><br><span class="line">                       content=fields.TEXT,</span><br><span class="line">                       modified=fields.DATETIME(sortable=<span class="literal">True</span>)</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<p>可以对没有 <code>sortable=True</code> 的字段进行排序，但这需要 Whoosh 将字段中的唯一词条加载到内存中。 使用 <code>sortable</code> 效率更高。</p>
<h3 id="关于列类型"><a href="#关于列类型" class="headerlink" title="关于列类型"></a>关于列类型</h3><p>当你使用 <code>sortable=True</code> 创建一个字段时，你是在告诉 Whoosh 将该字段的每个文档值存储在一个列中。 列对象指定用于在磁盘上存储每个文档值的格式。</p>
<p>whoosh.columns 模块包含几个不同的列对象实现。 每个字段类型指定一个合理的默认列类型（例如，文本字段的默认值是 whoosh.columns.VarBytesColumn，数字字段的默认值是 whoosh.columns.NumericColumn）。 但是，如果你想要最大效率，你可能希望为字段使用不同的列类型。</p>
<p>例如，如果字段中的所有文档值都是固定长度，则可以使用 whoosh.columns.FixedBytesColumn。 如果你有一个字段，其中许多文档共享相对较少的可能值（示例可能是“类别”字段，或“月份”或其他枚举类型字段），你可能希望使用 whoosh.columns.RefBytesColumn（ 可以处理可变和固定长度的值）。 有用于存储每个文档位值、结构、腌制对象和压缩字节值的列类型。</p>
<p>要为字段指定自定义列对象，请将其作为 sortable 关键字参数而不是 True 传递：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> columns, fields</span><br><span class="line"></span><br><span class="line">category_col = columns.RefBytesColumn()</span><br><span class="line">schema = fields.Schema(title=fields.TEXT(sortable=<span class="literal">True</span>),</span><br><span class="line">                       category=fields.KEYWORD(sortable=category_col)</span><br></pre></td></tr></table></figure>

<h2 id="使用-COLUMN-字段作为自定义排序键"><a href="#使用-COLUMN-字段作为自定义排序键" class="headerlink" title="使用 COLUMN 字段作为自定义排序键"></a>使用 COLUMN 字段作为自定义排序键</h2><p>当你添加带有可排序字段的文档时，Whoosh 使用你为该字段传递的值作为可排序值。 例如，如果“标题”是一个可排序的字段，并且你添加了这个文档：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.add_document(title=<span class="string">&quot;Mr. Palomar&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>…然后将 Palomar 先生作为文档的排序键存储在字段列中。</p>
<p>这通常很好，但有时你需要“修改”可排序键，使其与用户在界面中搜索和&#x2F;或看到的值不同。 例如，如果你允许用户按标题排序，你可能希望对可见标题和用于排序的值使用不同的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可见标题</span></span><br><span class="line">title = <span class="string">&quot;The Unbearable Lightness of Being&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序的标题：转换为小写（以防止排序不同</span></span><br><span class="line"><span class="comment"># 取决于大写/小写），开头的文章移到末尾</span></span><br><span class="line">sort_title = <span class="string">&quot;unbearable lightness of being, the&quot;</span></span><br></pre></td></tr></table></figure>

<p>最好的方法是使用一个额外的字段来进行排序。 你可以使用 whoosh.fields.COLUMN 字段类型来创建一个没有索引或存储的字段，它只包含每个文档的列值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(title=fields.TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                       sort_title=fields.COLUMN(columns.VarBytesColumn())</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<p>whoosh.fields.COLUMN 初始值设定项的单个参数是 whoosh.columns.ColumnType 对象。 你可以在 whoosh.columns 模块中使用各种列类型中的任何一种。</p>
<p>再举一个例子，假设你要索引的文档具有与每个文档关联的自定义排序顺序，例如“优先级”编号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name=Big Wheel</span><br><span class="line">price=<span class="number">100</span></span><br><span class="line">priority=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">name=Toss Across</span><br><span class="line">price=<span class="number">40</span></span><br><span class="line">priority=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">name=Slinky</span><br><span class="line">price=<span class="number">25</span></span><br><span class="line">priority=<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>你可以使用带有数字列对象的列字段来保存“优先级”并将其用于排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(name=fields.TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                       price=fields.NUMERIC(stored=<span class="literal">True</span>),</span><br><span class="line">                       priority=fields.COLUMN(columns.NumericColumn(<span class="string">&quot;i&quot;</span>),</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure>

<p>（请注意，columns.NumericColumn 采用类型代码字符，就像 Python 的结构和数组模块使用的代码一样。）</p>
<h3 id="使现有字段可排序"><a href="#使现有字段可排序" class="headerlink" title="使现有字段可排序"></a>使现有字段可排序</h3><p>如果在 Whoosh 3.0 中添加可排序参数之前你有一个现有索引，或者你认为不需要某个字段可排序但现在你发现需要对其进行排序，则可以将“可排序性”添加到现有索引中 使用 whoosh.sorting.add_sorta 索引 ble() 效用函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> columns, fields, index, sorting</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们有一个具有此模式的现有索引</span></span><br><span class="line">schema = fields.Schema(title=fields.TEXT,</span><br><span class="line">                       price=fields.NUMERIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用 add_sortable，首先要为索引打开一个 writer</span></span><br><span class="line">ix = index.open_dir(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> ix.writer() <span class="keyword">as</span> w:</span><br><span class="line">    <span class="comment"># 将 sortable=True 添加到“价格”字段，使用字段词条作为</span></span><br><span class="line">    <span class="comment"># 可排序的值</span></span><br><span class="line">    sorting.add_sortable(w, <span class="string">&quot;price&quot;</span>, sorting.FieldFacet(<span class="string">&quot;price&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 sortable=True 添加到“标题”字段</span></span><br><span class="line">    <span class="comment"># 存储字段值作为可排序值</span></span><br><span class="line">    sorting.add_sortable(w, <span class="string">&quot;title&quot;</span>, sorting.StoredFieldFacet(<span class="string">&quot;title&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>你可以在使用 column 关键字参数调用 add_sortable 时指定自定义列类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_sortable(w, <span class="string">&quot;chapter&quot;</span>, sorting.FieldFacet(<span class="string">&quot;chapter&quot;</span>),</span><br><span class="line">             column=columns.RefBytesColumn())</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅 add_sortable() 的文档。</p>
<h3 id="排序搜索结果"><a href="#排序搜索结果" class="headerlink" title="排序搜索结果"></a>排序搜索结果</h3><p>当你告诉 Whoosh 按一个（或多个）字段排序时，它使用字段列中的每个文档值作为文档的排序键。</p>
<p>通常，搜索结果按相关性得分降序排列。 你可以通过将 sortedby 关键字参数传递给 search() 方法来告诉 Whoosh 使用不同的顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> fields, index, qparser</span><br><span class="line"></span><br><span class="line">schema = fields.Schema(title=fields.TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                       price=fields.NUMERIC(sortable=<span class="literal">True</span>))</span><br><span class="line">ix = index.create_in(<span class="string">&quot;indexdir&quot;</span>, schema)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ix.writer() <span class="keyword">as</span> w:</span><br><span class="line">    w.add_document(title=<span class="string">&quot;Big Deal&quot;</span>, price=<span class="number">20</span>)</span><br><span class="line">    w.add_document(title=<span class="string">&quot;Mr. Big&quot;</span>, price=<span class="number">10</span>)</span><br><span class="line">    w.add_document(title=<span class="string">&quot;Big Top&quot;</span>, price=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> s:</span><br><span class="line">    qp = qparser.QueryParser(<span class="string">&quot;big&quot;</span>, ix.schema)</span><br><span class="line">    q = qp.parse(user_query_string)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将搜索结果从低到高排序</span></span><br><span class="line">    results = s.search(q, sortedby=<span class="string">&quot;price&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> hit <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(hit[<span class="string">&quot;title&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>你可以使用以下任何对象作为 sortedby 值：</p>
<p>一个 <code>FacetType</code> 对象<br>使用此对象对文档进行排序。 有关可用的构面类型，请参见下文。</p>
<p>字段名称字符串<br>将字段名称转换为 FieldFacet（见下文）并使用它对文档进行排序。</p>
<p><code>FacetType</code> 对象和&#x2F;或字段名称字符串的列表<br>将各个方面捆绑在一起成为一个 MultiFacet，以便你可以按多个键进行排序。 请注意，此快捷方式不允许你反转单个构面的排序方向。 为此，你需要自己构造 MultiFacet 对象。</p>
<blockquote>
<p>笔记</p>
<p>你可以使用 Searcher.search() 方法的 reverse&#x3D;True 关键字参数来反转整体排序方向。 这比反转每个单独的面更有效。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>按大小字段的值排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = searcher.search(myquery, sortedby=<span class="string">&quot;size&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>按“价格”字段的相反（从高到低）顺序排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">facet = sorting.FieldFacet(<span class="string">&quot;price&quot;</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">results = searcher.search(myquery, sortedby=facet)</span><br></pre></td></tr></table></figure>

<p>按大小升序排序，然后按价格降序排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mf = sorting.MultiFacet()</span><br><span class="line">mf.add_field(<span class="string">&quot;size&quot;</span>)</span><br><span class="line">mf.add_field(<span class="string">&quot;price&quot;</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">results = searcher.search(myquery, sortedby=mf)</span><br><span class="line"></span><br><span class="line">＃ 或者...</span><br><span class="line">sizes = sorting.FieldFacet(<span class="string">&quot;size&quot;</span>)</span><br><span class="line">prices = sorting.FieldFacet(<span class="string">&quot;price&quot;</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">results = searcher.search(myquery, sortedby=[sizes, prices])</span><br></pre></td></tr></table></figure>

<p>按“类别”字段排序，然后按文档的分数排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cats = sorting.FieldFacet(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">scores = sorting.ScoreFacet()</span><br><span class="line">results = searcher.search(myquery, sortedby=[cats, scores])</span><br></pre></td></tr></table></figure>

<h3 id="访问列值"><a href="#访问列值" class="headerlink" title="访问列值"></a>访问列值</h3><p>每个文档的列值在 Hit 对象中可用，就像存储的字段值一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(title=fields.TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                       price=fields.NUMERIC(sortable=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">results = searcher.search(myquery)</span><br><span class="line"><span class="keyword">for</span> hit <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(hit[<span class="string">&quot;title&quot;</span>], hit[<span class="string">&quot;price&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>高级：如果你想快速访问每个文档的任意值，你可以获得一个列阅读器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> s:</span><br><span class="line">    reader = s.reader()</span><br><span class="line"></span><br><span class="line">    colreader = s.reader().column_reader(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> docnum <span class="keyword">in</span> reader.all_doc_ids():</span><br><span class="line">        <span class="built_in">print</span>(colreader[docnum])</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>向用户呈现“多面”搜索结果通常非常有用。 分面是将搜索结果动态分组到类别中。 这些类别让用户可以根据他们感兴趣的类别查看总结果的一部分。</p>
<p>例如，如果你正在编写一个购物网站，你可能希望显示带有制造商和价格范围等搜索结果的类别。</p>
<table>
<thead>
<tr>
<th>制造商</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>苹果 (5)</td>
<td>$0 - $100 (2)</td>
</tr>
<tr>
<td>三洋 (1)</td>
<td>$101 - $500 (10)</td>
</tr>
<tr>
<td>索尼 (2)</td>
<td>$501 - $1000 (1)</td>
</tr>
<tr>
<td>东芝 (5)</td>
<td></td>
</tr>
</tbody></table>
<p>你可以让你的用户单击不同的构面值以仅显示给定类别中的结果。</p>
<p>另一个有用的 UI 模式是显示不同类型的已找到文档的前 5 个结果，并让用户单击以查看他们感兴趣的类别的更多结果，类似于 Spotlight 快速结果在 Mac OS 上的工作方式 X。</p>
<h3 id="groupedby-关键字参数"><a href="#groupedby-关键字参数" class="headerlink" title="groupedby 关键字参数"></a><code>groupedby</code> 关键字参数</h3><p>你可以使用以下对象作为 groupedby 值：</p>
<p><strong>一个 <code>FacetType</code> 对象</strong><br>使用此对象对文档进行分组。 有关可用的构面类型，请参见下文。</p>
<p><strong>字段名称字符串</strong><br>将字段名称转换为 FieldFacet（见下文）并使用它对文档进行排序。 字段名称用作构面名称。</p>
<p><strong>字段名称字符串的列表或元组</strong><br>设置多个字段分组条件。</p>
<p><strong>将构面名称映射到 FacetType 对象的字典</strong><br>设置多个分组标准。</p>
<p><strong>一个 Facets 对象</strong><br>这个对象很像使用字典，但有一些方便的方法可以更容易地设置多个分组。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>按“类别”字段的值分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = searcher.search(myquery, groupedby=<span class="string">&quot;category&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>按“类别”字段的值以及“标签”字段的值和日期范围分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cats = sorting.FieldFacet(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">tags = sorting.FieldFacet(<span class="string">&quot;tags&quot;</span>, allow_overlap=<span class="literal">True</span>)</span><br><span class="line">results = searcher.search(myquery, groupedby=&#123;<span class="string">&quot;category&quot;</span>: cats, <span class="string">&quot;tags&quot;</span>: tags&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...或者，使用 Facets 对象会减少一些重复</span></span><br><span class="line">facets = sorting.Facets()</span><br><span class="line">facets.add_field(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">facets.add_field(<span class="string">&quot;tags&quot;</span>, allow_overlap=<span class="literal">True</span>)</span><br><span class="line">results = searcher.search(myquery, groupedby=facets)</span><br></pre></td></tr></table></figure>

<p>要按多个字段的相交值对结果进行分组，请使用 MultiFacet 对象（见下文）。 例如，如果你有两个名为 tag 和 size 的字段，则可以按 tag 和 size 字段的所有组合对结果进行分组，例如 (‘tag1’, ‘small’), (‘tag2’, ‘small’), (‘tag1’, ‘medium’), 等等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据“tag”和“size”字段的组合生成一个分组</span></span><br><span class="line">mf = MultiFacet([<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;size&quot;</span>])</span><br><span class="line">results = searcher.search(myquery, groupedby=&#123;<span class="string">&quot;tag/size&quot;</span>: mf&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="获取分面组"><a href="#获取分面组" class="headerlink" title="获取分面组"></a>获取分面组</h3><p>Results.groups(“facetname”) 方法返回一个将类别名称映射到文档 ID 列表的字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myfacets = sorting.Facets().add_field(<span class="string">&quot;size&quot;</span>).add_field(<span class="string">&quot;tag&quot;</span>)</span><br><span class="line">results = mysearcher.search(myquery, groupedby=myfacets)</span><br><span class="line">results.groups(<span class="string">&quot;size&quot;</span>)</span><br><span class="line"><span class="comment"># &#123;&quot;small&quot;: [8, 5, 1, 2, 4], &quot;medium&quot;: [3, 0, 6], &quot;large&quot;: [7, 9]&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个方面，你可以只使用不带参数的 Results.groups() 来访问其组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results = mysearcher.search(myquery, groupedby=myfunctionfacet)</span><br><span class="line">results.groups()</span><br></pre></td></tr></table></figure>

<p>默认情况下，groups() 返回的字典中的值是文档编号列表，其相对顺序与结果中的顺序相同。 你可以使用 Searcher 对象的 stored_fields() 方法获取文档编号并将文档的存储字段作为字典返回：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> category_name <span class="keyword">in</span> categories:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Top 5 documents in the %s category&quot;</span> % category_name</span><br><span class="line">    doclist = categories[category_name]</span><br><span class="line">    <span class="keyword">for</span> docnum, score <span class="keyword">in</span> doclist[:<span class="number">5</span>]:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;  &quot;</span>, searcher.stored_fields(docnum)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(doclist) &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;  (%s more)&quot;</span> % (<span class="built_in">len</span>(doclist) - <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>如果你想要有关组的不同信息，例如只需要每个组中的文档数，或者你不需要对组进行排序，则可以指定 whoosh.sorting.FacetMap 类型或带有 maptype 关键字参数的实例 创建 FacetType：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个和默认的一样</span></span><br><span class="line">myfacet = FieldFacet(<span class="string">&quot;size&quot;</span>, maptype=sorting.OrderedList)</span><br><span class="line">results = mysearcher.search(myquery, groupedby=myfacet)</span><br><span class="line">results.groups()</span><br><span class="line"><span class="comment"># &#123;&quot;small&quot;: [8, 5, 1, 2, 4], &quot;medium&quot;: [3, 0, 6], &quot;large&quot;: [7, 9]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不要对组进行排序以匹配结果中文档的顺序（快点）</span></span><br><span class="line">myfacet = FieldFacet(<span class="string">&quot;size&quot;</span>, maptype=sorting.UnorderedList)</span><br><span class="line">results = mysearcher.search(myquery, groupedby=myfacet)</span><br><span class="line">results.groups()</span><br><span class="line"><span class="comment"># &#123;&quot;small&quot;: [1, 2, 4, 5, 8], &quot;medium&quot;: [0, 3, 6], &quot;large&quot;: [7, 9]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只统计每组中的文档</span></span><br><span class="line">myfacet = FieldFacet(<span class="string">&quot;size&quot;</span>, maptype=sorting.Count)</span><br><span class="line">results = mysearcher.search(myquery, groupedby=myfacet)</span><br><span class="line">results.groups()</span><br><span class="line"><span class="comment"># &#123;&quot;small&quot;: 5, &quot;medium&quot;: 3, &quot;large&quot;: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只记住每组中“最好”的文档</span></span><br><span class="line">myfacet = FieldFacet(<span class="string">&quot;size&quot;</span>, maptype=sorting.Best)</span><br><span class="line">results = mysearcher.search(myquery, groupedby=myfacet)</span><br><span class="line">results.groups()</span><br><span class="line"><span class="comment"># &#123;&quot;small&quot;: 8, &quot;medium&quot;: 3, &quot;large&quot;: 7&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者，你可以在适用于所有方面的 Searcher.search() 方法调用中指定 maptype 参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">results = mysearcher.search(myquery, groupedby=[<span class="string">&quot;size&quot;</span>, <span class="string">&quot;tag&quot;</span>],</span><br><span class="line">                            maptype=sorting.Count)</span><br></pre></td></tr></table></figure>

<p>（你也可以通过为它们指定 maptype 参数来覆盖各个方面的这个整体 maptype 参数。）</p>
<h3 id="刻面类型"><a href="#刻面类型" class="headerlink" title="刻面类型"></a>刻面类型</h3><h3 id="场面"><a href="#场面" class="headerlink" title="场面"></a>场面</h3><p>这是最常见的刻面类型。 它根据每个文档中特定字段中的值进行排序或分组。 如果每个文档在字段中只有一个词条（例如 ID 字段），这通常效果最好（或根本没有）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据“路径”字段的值对搜索结果进行排序</span></span><br><span class="line">facet = sorting.FieldFacet(<span class="string">&quot;path&quot;</span>)</span><br><span class="line">results = searcher.search(myquery, sortedby=facet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据“parent”字段的值对搜索结果进行分组</span></span><br><span class="line">facet = sorting.FieldFacet(<span class="string">&quot;parent&quot;</span>)</span><br><span class="line">results = searcher.search(myquery, groupedby=facet)</span><br><span class="line">parent_groups = results.groups(<span class="string">&quot;parent&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下，FieldFacet 仅支持非重叠分组，其中文档不能 t 同时属于多个方面（每个文档将被任意分类到一个类别中。）要获得具有多值字段的重叠组，请使用 allow_overlap&#x3D;True 关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facet = sorting.FieldFacet(fieldname, allow_overlap=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这支持重叠的组成员资格，其中文档在一个字段中有多个词条（例如 KEYWORD 字段）。 如果不需要重叠，请不要使用 allow_overlap，因为它的速度要慢得多并且会占用更多内存（请参阅下面有关 allow_overlap 的部分）。</p>
<h3 id="查询面"><a href="#查询面" class="headerlink" title="查询面"></a>查询面</h3><p>你可以设置由任意查询定义的类别。 例如，你可以使用前缀查询对名称进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用查询来定义每个类别</span></span><br><span class="line"><span class="comment">#（这里我假设“价格”是一个数字字段，所以我将使用数值范围）</span></span><br><span class="line">qdict = &#123;&#125;</span><br><span class="line">qdict[<span class="string">&quot;A-D&quot;</span>] = query.TermRange(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">qdict[<span class="string">&quot;E-H&quot;</span>] = query.TermRange(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">qdict[<span class="string">&quot;I-L&quot;</span>] = query.TermRange(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">qfacet = sorting.QueryFacet(qdict)</span><br><span class="line">r = searcher.search(myquery, groupedby=&#123;<span class="string">&quot;firstltr&quot;</span>: qfacet&#125;)</span><br></pre></td></tr></table></figure>

<p>默认情况下，QueryFacet 仅支持非重叠分组，即一个文档不能同时属于多个切面（每个文档将被任意归入一个类别）。 要获得具有多值字段的重叠组，请使用 allow_overlap&#x3D;True 关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facet = sorting.QueryFacet(querydict, allow_overlap=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="范围面"><a href="#范围面" class="headerlink" title="范围面"></a>范围面</h3><p>RangeFacet 适用于 NUMERIC 字段类型。 它将一系列可能的值分成几组。 例如，根据价格将文档分组到“宽”100 美元的桶中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pricefacet = sorting.RangeFacet(<span class="string">&quot;price&quot;</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>第一个参数是字段的名称。 接下来的两个参数是要划分的完整范围。 超出此范围的值（在此示例中，小于 0 和大于 1000 的值）将被分类到“缺失”（无）组中。 第四个参数是“间隙大小”，即范围内划分的大小。</p>
<p>“差距”可以是一个列表而不是单个值。 在这种情况下，列表中的值将用于设置初始分区的大小，列表中的最后一个值是所有后续分区的大小。 例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pricefacet = sorting.RangeFacet(<span class="string">&quot;price&quot;</span>, <span class="number">0</span>, <span class="number">1000</span>, [<span class="number">5</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>

<p>…将设置 0-5、5-15、15-50、50-100 的划分，然后使用 50 作为所有后续划分的大小（即 100-150、150-200 等）。</p>
<p>hardend 关键字参数控制最后一个除法是被限制在范围的末尾还是允许超过范围的末尾。 例如，这个：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facet = sorting.RangeFacet(<span class="string">&quot;num&quot;</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>, hardend=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>…给出分区 0-4、4-8 和 8-12，同时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">facet = sorting.RangeFacet(<span class="string">&quot;num&quot;</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>, hardend=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>…给出分区 0-4、4-8 和 8-10。 （默认为 hardend&#x3D;False。）</p>
<blockquote>
<p>笔记</p>
<p>范围&#x2F;桶总是在开始时包含在内，在结束时不包含在内。</p>
</blockquote>
<h3 id="日期范围面"><a href="#日期范围面" class="headerlink" title="日期范围面"></a>日期范围面</h3><p>这类似于 RangeFacet，但适用于 DATETIME 字段。 起始值和结束值必须是 datetime.datetime 对象，间隙是 datetime.timedelta 对象。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line">start = datetime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end = datetime.now()</span><br><span class="line">gap = timedelta(days=<span class="number">365</span>)</span><br><span class="line">bdayfacet = sorting.DateRangeFacet(<span class="string">&quot;birthday&quot;</span>, start, end, gap)</span><br></pre></td></tr></table></figure>

<p>与 RangeFacet 一样，你可以使用间隙列表和 hardend 关键字参数。</p>
<h3 id="分数面"><a href="#分数面" class="headerlink" title="分数面"></a>分数面</h3><p>这个方面有时对排序很有用。</p>
<p>例如，要按“类别”字段排序，然后对于具有相同类别的文档，按文档的分数排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cats = sorting.FieldFacet(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">scores = sorting.ScoreFacet()</span><br><span class="line">results = searcher.search(myquery, sortedby=[cats, scores])</span><br></pre></td></tr></table></figure>

<p>ScoreFacet 始终将较高的分数排在较低的分数之前。</p>
<blockquote>
<p>笔记</p>
<p>虽然使用 sortedby&#x3D;ScoreFacet() 应该给出与使用默认评分排序 (sortedby&#x3D;None) 相同的结果，但使用 facet 会更慢，因为排序时 Whoosh 会自动关闭许多优化。</p>
</blockquote>
<h3 id="功能面"><a href="#功能面" class="headerlink" title="功能面"></a>功能面</h3><p>此方面允许你传递自定义函数来计算文档的排序&#x2F;分组键。 （使用此方面类型可能比子类化 FacetType 和 Categorizer 更容易设置一些自定义行为。）</p>
<p>该函数将以索引搜索器和索引文档 ID 作为参数调用。 例如，如果你有一个包含词条向量的索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(<span class="built_in">id</span>=fields.STORED,</span><br><span class="line">                       text=fields.TEXT(stored=<span class="literal">True</span>, vector=<span class="literal">True</span>))</span><br><span class="line">ix = RamStorage().create_index(schema)</span><br></pre></td></tr></table></figure>

<p>…你可以使用函数对文档进行排序，它们越接近两个词条的相等出现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">searcher, docnum</span>):</span><br><span class="line">    v = <span class="built_in">dict</span>(searcher.vector_as(<span class="string">&quot;frequency&quot;</span>, docnum, <span class="string">&quot;text&quot;</span>))</span><br><span class="line">    <span class="comment"># Sort documents that have equal number of &quot;alfa&quot; and &quot;bravo&quot; first</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> - (<span class="number">1.0</span> / (<span class="built_in">abs</span>(v.get(<span class="string">&quot;alfa&quot;</span>, <span class="number">0</span>) - v.get(<span class="string">&quot;bravo&quot;</span>, <span class="number">0</span>)) + <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">facet = sorting.FunctionFacet(fn)</span><br><span class="line">results = searcher.search(myquery, sortedby=facet)</span><br></pre></td></tr></table></figure>

<h3 id="StoredFieldFacet"><a href="#StoredFieldFacet" class="headerlink" title="StoredFieldFacet"></a>StoredFieldFacet</h3><p>此方面允许你使用存储的字段值作为文档的排序&#x2F;分组键。 这通常比使用索引字段慢，但是 w 当使用 allow_overlap 时，它对于大型索引实际上可以更快，因为它避免了读取发布列表的开销。</p>
<p>StoredFieldFacet 通过将存储值拆分为单独的键来支持 allow_overlap。 默认情况下，它调用值的 split() 方法（因为大多数存储值都是字符串），但你可以提供自定义拆分函数。 请参阅下面有关 allow_overlap 的部分。</p>
<h3 id="多方面"><a href="#多方面" class="headerlink" title="多方面"></a>多方面</h3><p>此构面类型返回由两个或多个子构面返回的键的组合，允许你按多个构面的相交值进行排序&#x2F;分组。</p>
<p>MultiFacet 有添加分面的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myfacet = sorting.RangeFacet(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">mf = sorting.MultiFacet()</span><br><span class="line">mf.add_field(<span class="string">&quot;category&quot;</span>)</span><br><span class="line">mf.add_field(<span class="string">&quot;price&quot;</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">mf.add_facet(myfacet)</span><br><span class="line">mf.add_score()</span><br></pre></td></tr></table></figure>

<p>你还可以将字段名称列表和&#x2F;或 FacetType 对象传递给初始化程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prices = sorting.FieldFacet(<span class="string">&quot;price&quot;</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">scores = sorting.ScoreFacet()</span><br><span class="line">mf = sorting.MultiFacet([<span class="string">&quot;category&quot;</span>, prices, myfacet, scores])</span><br></pre></td></tr></table></figure>

<h3 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h3><ul>
<li>排序时，在给定字段中没有任何词条的文档，或任何其他构成不同方面类型的“缺失”的文档，将始终排序到最后。</li>
<li>分组时，“丢失”的文档将出现在一个键为 None 的组中。</li>
</ul>
<h3 id="使用重叠组"><a href="#使用重叠组" class="headerlink" title="使用重叠组"></a>使用重叠组</h3><p>用于分组和排序的常见支持工作流是给定字段具有一个文档值，例如包含原始文档文件路径的路径字段。 默认情况下，构面设置为支持这种单值方法。</p>
<p>当然，在某些情况下，你希望根据每个文档具有多个词条的字段将文档分类到多个组中。 最常见的示例是标签字段。 FieldFacet、QueryFacet 和 StoredFieldFacet 的 allow_overlap 关键字参数允许这种多值方法。</p>
<p>但是，有一个重要的警告：使用 allow_overlap&#x3D;True 比默认值慢，对于非常大的结果集可能慢得多。 这是因为 Whoosh 必须读取该字段中每个词条的每个帖子，以创建一个临时的“前向索引”映射文档到词条。</p>
<p>如果一个字段使用词条向量进行索引，FieldFacet 将使用它们来加速小型结果集的 allow_overlap 分面，但对于大型结果集，Whoosh 必须为每个匹配的文档打开向量列表，这仍然可能非常慢。</p>
<p>对于非常大的索引和结果集，如果存储了一个字段，你可以使用 StoredFieldFacet 而不是 FieldFacet 获得更快的重叠分面。 虽然读取存储值通常比使用索引慢，但在这种情况下，避免打开大量发布阅读器的开销是值得的。</p>
<p>StoredFieldFacet 通过加载给定字段的存储值并将其拆分为多个值来支持 allow_overlap。 默认是调用值的 split() 方法。</p>
<p>例如，如果你将标签字段存储为类似“tag1 tag2 tag3”的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schema = fields.Schema(name=fields.TEXT(stored=<span class="literal">True</span>),</span><br><span class="line">                       tags=fields.KEYWORD(stored=<span class="literal">True</span>))</span><br><span class="line">ix = index.create_in(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> ix.writer() <span class="keyword">as</span> w:</span><br><span class="line">    w.add_document(name=<span class="string">&quot;A Midsummer Night&#x27;s Dream&quot;</span>, tags=<span class="string">&quot;comedy fairies&quot;</span>)</span><br><span class="line">    w.add_document(name=<span class="string">&quot;Hamlet&quot;</span>, tags=<span class="string">&quot;tragedy denmark&quot;</span>)</span><br><span class="line">    <span class="comment"># etc.</span></span><br></pre></td></tr></table></figure>

<p>…然后你可以像这样使用 StoredFieldFacet：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ix = index.open_dir(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> s:</span><br><span class="line">    sff = sorting.StoredFieldFacet(<span class="string">&quot;tags&quot;</span>, allow_overlap=<span class="literal">True</span>)</span><br><span class="line">    results = s.search(myquery, groupedby=&#123;<span class="string">&quot;tags&quot;</span>: sff&#125;)</span><br></pre></td></tr></table></figure>

<p>对于字符串以外的存储 Python 对象，你可以提供一个拆分函数（使用 StoredFieldFacet 的 split_fn 关键字参数）。 该函数应接受单个参数（存储的值）并返回分组键的列表或元组。</p>
<h2 id="使用自定义排序顺序"><a href="#使用自定义排序顺序" class="headerlink" title="使用自定义排序顺序"></a>使用自定义排序顺序</h2><p>每次搜索自定义排序顺序有时很有用。 例如，不同的语言使用不同的排序顺序。 如果你有一个函数可以为给定的字段值返回你想要的排序顺序，例如 Unicode 归类算法 (UCA) 的实现，你可以为用户的语言自定义排序顺序。</p>
<p>whoosh.sorting.TranslateFacet 允许你将函数应用于另一个方面的值。 这使你可以将字段值“翻译”为任意排序键，例如使用 UCA：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyuca <span class="keyword">import</span> Collator</span><br><span class="line"></span><br><span class="line"><span class="comment"># Collator 对象有一个 sort_key() 方法，它接受一个 unicode</span></span><br><span class="line"><span class="comment"># 字符串并返回一个排序键</span></span><br><span class="line">c = Collator(<span class="string">&quot;allkeys.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为要排序的字段创建一个 facet 对象</span></span><br><span class="line">nf = sorting.FieldFacet(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用翻译函数将构面包装在 TranslateFacet 中</span></span><br><span class="line"><span class="comment">#（Collator 对象的 sort_key 方法）</span></span><br><span class="line">tf = sorting.TranslateFacet(facet, c.sort_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切面对搜索结果进行排序</span></span><br><span class="line">results = searcher.search(myquery, sortedby=tf)</span><br></pre></td></tr></table></figure>

<p>（你可以将多个“包装的”面传递给 TranslateFacet，它会使用面的值作为多个参数调用该函数。）</p>
<p>TranslateFacet 对于数字字段也非常有用，可以根据 o 进行排序<br>一些公式的输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据两个数字字段的平均值排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为字段创建两个方面，并将它们与函数一起传递给翻译面</span></span><br><span class="line">af = sorting.FieldFacet(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">wf = sorting.FieldFacet(<span class="string">&quot;weight&quot;</span>)</span><br><span class="line">facet = sorting.TranslateFacet(average, af, wf)</span><br><span class="line"></span><br><span class="line">results = searcher.search(myquery. sortedby=facet)</span><br></pre></td></tr></table></figure>

<p>请记住，你仍然可以按多个方面进行排序。 例如，你可以先按量化函数转换的数值排序，然后如果相等，则按另一个字段的值排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先按量化大小排序，然后按名称排序</span></span><br><span class="line">tf = sorting.TranslateFacet(quantize, sorting.FieldFacet(<span class="string">&quot;size&quot;</span>))</span><br><span class="line">results = searcher.search(myquery, sortedby=[tf, <span class="string">&quot;name&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>专家：写自己的切面<br>待定。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Whoosh/" rel="tag"># Whoosh</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/whoosh/15-%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%20(highlighted)%20%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/" rel="prev" title="Whoosh 15 - 高亮显示 (highlighted) 搜索结果">
                  <i class="fa fa-chevron-left"></i> Whoosh 15 - 高亮显示 (highlighted) 搜索结果
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/whoosh/13-%E7%B4%A2%E5%BC%95%E5%92%8C%E6%90%9C%E7%B4%A2%20N-gram/" rel="next" title="Whoosh 13 - 索引和搜索 N-gram">
                  Whoosh 13 - 索引和搜索 N-gram <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>

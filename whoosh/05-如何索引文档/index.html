<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"luohuayong.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.17.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="创建索引对象要在目录中创建索引，请使用 index.create_in ：">
<meta property="og:type" content="article">
<meta property="og:title" content="Whoosh 05 - 如何为文档编制索引">
<meta property="og:url" content="https://luohuayong.github.io/whoosh/05-%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="创建索引对象要在目录中创建索引，请使用 index.create_in ：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-20T13:27:13.123Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="Whoosh">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://luohuayong.github.io/whoosh/05-%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://luohuayong.github.io/whoosh/05-%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3/","path":"whoosh/05-如何索引文档/","title":"Whoosh 05 - 如何为文档编制索引"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Whoosh 05 - 如何为文档编制索引 | 技术博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">技术博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">创建索引对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">2.</span> <span class="nav-text">清除索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E6%96%87%E6%A1%A3%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">3.</span> <span class="nav-text">为文档创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%90%8C%E4%B8%80%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E5%92%8C%E5%AD%98%E5%82%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC"><span class="nav-number">3.1.</span> <span class="nav-text">为同一字段创建索引和存储不同的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%88%90%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3"><span class="nav-number">3.2.</span> <span class="nav-text">完成添加文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%AE%B5-segments"><span class="nav-number">4.</span> <span class="nav-text">合并段 (segments)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3"><span class="nav-number">5.</span> <span class="nav-text">删除文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3"><span class="nav-number">6.</span> <span class="nav-text">更新文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">7.</span> <span class="nav-text">增量索引</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Leo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luohuayong.github.io/whoosh/05-%E5%A6%82%E4%BD%95%E7%B4%A2%E5%BC%95%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Leo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Whoosh 05 - 如何为文档编制索引 | 技术博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Whoosh 05 - 如何为文档编制索引
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-06-20 00:00:00 / 修改时间：21:27:13" itemprop="dateCreated datePublished" datetime="2023-06-20T00:00:00+08:00">2023-06-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="创建索引对象"><a href="#创建索引对象" class="headerlink" title="创建索引对象"></a>创建索引对象</h2><p>要在目录中创建索引，请使用 <code>index.create_in</code> ：</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, os.path</span><br><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;indexdir&quot;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line"></span><br><span class="line">ix = index.create_in(<span class="string">&quot;indexdir&quot;</span>, schema)</span><br></pre></td></tr></table></figure>

<p>要打开目录中的现有索引，请使用 <code>index.open_dir</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whoosh.index <span class="keyword">as</span> index</span><br><span class="line"></span><br><span class="line">ix = index.open_dir(<span class="string">&quot;indexdir&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这些是简便方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.filedb.filestore <span class="keyword">import</span> FileStorage</span><br><span class="line">storage = FileStorage(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个索引</span></span><br><span class="line">ix = storage.create_index(schema)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开一个已存在的索引</span></span><br><span class="line">storage.open_index()</span><br></pre></td></tr></table></figure>

<p>创建索引时使用的模式 (schema) 将随索引一起存储。</p>
<p>你可以使用 <code>indexname</code> 关键字将多个索引保留在同一目录中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用简便函数</span></span><br><span class="line">ix = index.create_in(<span class="string">&quot;indexdir&quot;</span>, schema=schema, indexname=<span class="string">&quot;usages&quot;</span>)</span><br><span class="line">ix = index.open_dir(<span class="string">&quot;indexdir&quot;</span>, indexname=<span class="string">&quot;usages&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Storage 对象</span></span><br><span class="line">ix = storage.create_index(schema, indexname=<span class="string">&quot;usages&quot;</span>)</span><br><span class="line">ix = storage.open_index(indexname=<span class="string">&quot;usages&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="清除索引"><a href="#清除索引" class="headerlink" title="清除索引"></a>清除索引</h2><p>在一个已存在索引的目录中调用 <code>index.create_in</code> 将清除索引的当前内容。</p>
<p>要测试目录当前是否包含有效索引，请使用 <code>index.exists_in</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists = index.exists_in(<span class="string">&quot;indexdir&quot;</span>)</span><br><span class="line">usages_exists = index.exists_in(<span class="string">&quot;indexdir&quot;</span>, indexname=<span class="string">&quot;usages&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>（或者，你可以简单地从目录中删除索引的文件，例如如果目录中只有一个索引，请使用 <code>shutil.rmtree</code> 删除目录，然后重新创建它。）</p>
<h2 id="为文档创建索引"><a href="#为文档创建索引" class="headerlink" title="为文档创建索引"></a>为文档创建索引</h2><p>创建 <code>Index</code> 对象后，可以使用 <code>IndexWriter</code> 对象将文档添加到索引中。获得 <code>IndexWriter</code> 的最简单方法是调用 <code>Index.writer()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ix = index.open_dir(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">writer = ix.writer()</span><br></pre></td></tr></table></figure>

<p>创建写入器 (writer) 会锁定索引以便进行写入，因此在同一线程或进程中同一时间只能由一个写入器打开。</p>
<blockquote>
<p>注意<br>因为打开写入器 (writer) 会锁定索引以进行写入，在多线程或多进程环境中，你的代码需要非常小心，如果试图打开一个已经被打开的索引将抛出 <code>whoosh.store.LockError</code> 异常。Whoosh 包括几个解决了写入锁 （whoosh.writing.AsyncWriter 和 whoosh.writing.BufferedWriter） 的示例方法。</p>
</blockquote>
<hr>
<blockquote>
<p>注意<br>当写入器 (writer) 处于打开状态并在提交期间，索引仍处于打开状态可供查询。现有读入器 (readers) 不受影响，新的读入器 (readers) 也可以正常打开当前索引。提交完成后，现有读入器 (readers) 继续看到以前版本的索引，他们不会自动看到新提交的更改。新读入器 (readers) 将看到更新后的索引。</p>
</blockquote>
<p>索引写入器 (IndexWriter) 的 <code>add_document(**kwargs)</code> 方法的参数是字段名与字段值组成的键值对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">writer = ix.writer()</span><br><span class="line">writer.add_document(title=<span class="string">u&quot;My document&quot;</span>, content=<span class="string">u&quot;This is my document!&quot;</span>,</span><br><span class="line">                    path=<span class="string">u&quot;/a&quot;</span>, tags=<span class="string">u&quot;first short&quot;</span>, icon=<span class="string">u&quot;/icons/star.png&quot;</span>)</span><br><span class="line">writer.add_document(title=<span class="string">u&quot;Second try&quot;</span>, content=<span class="string">u&quot;This is the second example.&quot;</span>,</span><br><span class="line">                    path=<span class="string">u&quot;/b&quot;</span>, tags=<span class="string">u&quot;second short&quot;</span>, icon=<span class="string">u&quot;/icons/sheep.png&quot;</span>)</span><br><span class="line">writer.add_document(title=<span class="string">u&quot;Third time&#x27;s the charm&quot;</span>, content=<span class="string">u&quot;Examples are many.&quot;</span>,</span><br><span class="line">                    path=<span class="string">u&quot;/c&quot;</span>, tags=<span class="string">u&quot;short&quot;</span>, icon=<span class="string">u&quot;/icons/book.png&quot;</span>)</span><br><span class="line">writer.commit()</span><br></pre></td></tr></table></figure>

<p>你不必为每个字段填写一个值。Whoosh 不在乎你是否从文档中省略字段。</p>
<p>必须向索引字段传递 unicode 值。已存储但未索引的字段（即 <code>STORED</code> 字段类型）可以传递任何可 pickle 的对象。</p>
<p>Whoosh 并不介意你添加具有相同值的文档，如何使用取决于你的目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer.add_document(path=<span class="string">u&quot;/a&quot;</span>, title=<span class="string">u&quot;A&quot;</span>, content=<span class="string">u&quot;Hello there&quot;</span>)</span><br><span class="line">writer.add_document(path=<span class="string">u&quot;/a&quot;</span>, title=<span class="string">u&quot;A&quot;</span>, content=<span class="string">u&quot;Deja vu!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这会将两个具有相同路径和标题字段的文档添加到索引中。查看下面的 <a href="#%E6%9B%B4%E6%96%B0%E6%96%87%E6%A1%A3">更新文档</a> 以获取有关 <code>update_document</code> 方法的信息，其中被标记为 “unique” 的字段将替换旧文档而不是追加。</p>
<h3 id="为同一字段创建索引和存储不同的值"><a href="#为同一字段创建索引和存储不同的值" class="headerlink" title="为同一字段创建索引和存储不同的值"></a>为同一字段创建索引和存储不同的值</h3><p>如果你需要一个既有索引又有存储的字段，则可以创建一个 unicode 值的索引，并使用另一个特定的关键字参数 <code>_stored_&lt;fieldname&gt;</code> 存储对象（通常不这样做，但有时这很有用）。 正常值将被分析和索引，但 <code>_stored_&lt;fieldname&gt;</code> 字段的值将显示在结果中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.add_document(title=<span class="string">u&quot;Title to be indexed&quot;</span>, _stored_title=<span class="string">u&quot;Stored title&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="完成添加文档"><a href="#完成添加文档" class="headerlink" title="完成添加文档"></a>完成添加文档</h3><p>索引写入器 (<code>IndexWriter</code>) 对象有点像数据库事务。可以对一个索引进行大量更改，然后一次提交 (<code>commit</code>) 它们。</p>
<p>在 <code>IndexWriter</code> 上调用 <code>commit()</code> 将添加的文档保存到索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.commit()</span><br></pre></td></tr></table></figure>

<p>当文档添加到索引后，即可搜索它们。</p>
<p>如果要关闭写入器 (writer) 而不提交更改，请调用 <code>cancel()</code> 而非 <code>commit()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.cancel()</span><br></pre></td></tr></table></figure>

<p>请记住，当你打开了一个写入器（也包括你已经打开，并且在当前范围内仍然有效的写入器），没有其他线程或进程可以获取写入器 (writer) 或修改索引。一个写入器还保留对多个文件的打开状态。所以你应该永远记住在使用完写入器对象后调用 <code>commit()</code> 或 <code>cancel()</code>。</p>
<h2 id="合并段-segments"><a href="#合并段-segments" class="headerlink" title="合并段 (segments)"></a>合并段 (segments)</h2><p>Whoosh 的 <code>filedb</code> 索引实际上是一个或多个被称为段 (segments) 的“子索引”的容器。当你将文档添加到索引时，并不是将新文档与现有文档集成（这可能非常昂贵，因为它涉及对磁盘上的所有索引词条进行重新排序），Whoosh 在现有段旁边创建一个新段。 然后，当你搜索索引时，Whoosh 会分别搜索两个段并合并结果，因此这些段看起来是一个统一的索引。 （这个巧妙的设计是从 Lucene 复制而来的。）</p>
<p>因此，拥有几个段比每次添加一些文档时都重写整个索引更有效。 但是搜索多个段确实会减慢搜索速度，而且你拥有的段越多，搜索速度就越慢。 所以 Whoosh 有一个算法，当你调用 <code>commit()</code> 时会运行该算法，该算法会查找可以合并在一起的小段，从而生成更少、更大的段。</p>
<p>要防止 Whoosh 在提交期间合并段，请使用 <code>merge=False</code> 关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.commit(merge=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>将所有段合并在一起，将索引优化 (<code>optimize</code>) 为单个段，使用 <code>optimize=True</code> 关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writer.commit(optimize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>由于优化 (<code>optimize</code>) 会重写索引中的所有信息，因此在大型索引上可能会很慢。通常依赖 Whoosh 的合并算法比一直优化要好。</p>
<p>（<code>Index</code> 对象还有一个 <code>optimize()</code> 方法，可以让你优化索引（将所有段合并在一起）。它只是创建一个写入器 (writer) 并在其上调用 <code>commit(optimize=True)</code>。）</p>
<p>为了更好地控制段合并，你可以编写自己的合并策略函数并将其用作 <code>commit()</code> 方法的参数。查看 <code>whoosh.writing</code> 模块中 <code>NO_MERGE</code>、<code>MERGE_SMALL</code> 和 <code>OPTIMIZE</code> 函数的实现。</p>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>你可以在 <code>IndexWriter</code> 对象上使用以下方法删除文档。 然后，你需要调用写入器上的 <code>commit()</code> 方法以将删除内容保存到磁盘。</p>
<p><code>delete_document(docnum)</code><br>通过内部文档编号删除文档的低级方法。</p>
<p><code>is_deleted(docnum)</code><br>低级方法，如果删除具有给定内部编号的文档，则返回 <code>True</code>。</p>
<p><code>delete_by_term(fieldname, termtext)</code><br>删除给定（索引）字段包含给定词条 (<code>term</code>) 的任何文档。 这主要用于 <code>ID</code> 或 <code>KEYWORD</code> 字段。</p>
<p><code>delete_by_query(query)</code><br>删除与给定查询匹配的所有文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按路径删除文档 —— 这个字段必须已被索引</span></span><br><span class="line">ix.delete_by_term(<span class="string">&#x27;path&#x27;</span>, <span class="string">u&#x27;/a/b/c&#x27;</span>)</span><br><span class="line"><span class="comment"># 将删除后的内容保存到磁盘</span></span><br><span class="line">ix.commit()</span><br></pre></td></tr></table></figure>

<p>在 <code>filedb</code> 后端，删除文档只是将文档编号添加到与索引一起存储的已删除文档列表中。 当你搜索索引时，它知道不会在结果中返回已删除的文档。 然而，文档的内容仍然存储在索引中，并且某些统计信息（例如词条在文档中的频率）不会更新，直到你合并包含已删除文档的段（参见上面的合并）。 这是因为立即从索引中删除信息实际上会涉及在磁盘上重写整个索引，这将是非常低效的。</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><p>如果要替换（重新索引）文档，可以使用 <code>Index</code> 或 <code>IndexWriter</code> 上的 <code>delete_*</code> 方法之一删除旧文档，然后使用 <code>IndexWriter.add_document</code> 添加新版本。 或者你可以使用 <code>IndexWriter.update_document</code> 一步完成此操作。</p>
<p>要使 <code>update_document</code> 起作用，你必须至少将模式 (schema) 中的一个字段标记为唯一 (<code>unique=True</code>)。 然后 Whoosh 将使用唯一 (<code>unique=True</code>) 字段的内容来搜索要删除的文档：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> Schema, ID, TEXT</span><br><span class="line"></span><br><span class="line">schema = Schema(path = ID(unique=<span class="literal">True</span>), content=TEXT)</span><br><span class="line"></span><br><span class="line">ix = index.create_in(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">writer = ix.writer()</span><br><span class="line">writer.add_document(path=<span class="string">u&quot;/a&quot;</span>, content=<span class="string">u&quot;The first document&quot;</span>)</span><br><span class="line">writer.add_document(path=<span class="string">u&quot;/b&quot;</span>, content=<span class="string">u&quot;The second document&quot;</span>)</span><br><span class="line">writer.commit()</span><br><span class="line"></span><br><span class="line">writer = ix.writer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 &quot;path&quot; 字段被标记为唯一，所以在 path=&quot;/a&quot; 上调用 update_document</span></span><br><span class="line"><span class="comment"># 将删除 &quot;path&quot; 字段包含 &quot;/a&quot; 的任何现有文档。</span></span><br><span class="line">writer.update_document(path=<span class="string">u&quot;/a&quot;</span>, content=<span class="string">&quot;Replacement for the first document&quot;</span>)</span><br><span class="line">writer.commit()</span><br></pre></td></tr></table></figure>

<p>标记为唯一 (<code>unique</code>) 的字段必须被索引。</p>
<p>如果已有文档中不存在一个与更新文档的唯一字段相同值的文档，<code>update_document</code> 就像 <code>add_document</code> 一样。</p>
<p>唯一 (<code>unique</code>) 字段和 <code>update_document</code> 只是删除和添加的快捷方式。 Whoosh 没有唯一标识符的固有概念，并且在你使用 <code>add_document</code> 时绝不会强制执行唯一性。</p>
<h2 id="增量索引"><a href="#增量索引" class="headerlink" title="增量索引"></a>增量索引</h2><p>当你索引一组文档时，你通常需要两种代码路径：一种是从头开始索引所有文档，另一种是只更新已更改的文档。</p>
<p>从头开始索引所有内容非常容易。 这是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> index</span><br><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> Schema, ID, TEXT</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_index</span>(<span class="params">dirname</span>):</span><br><span class="line">  <span class="comment"># 始终从头开始创建索引</span></span><br><span class="line">  ix = index.create_in(dirname, schema=get_schema())</span><br><span class="line">  writer = ix.writer()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 假设我们有一个函数</span></span><br><span class="line">  <span class="comment"># 可以收集要索引的文档的文件名</span></span><br><span class="line">  <span class="keyword">for</span> path <span class="keyword">in</span> my_docs():</span><br><span class="line">    add_doc(writer, path)</span><br><span class="line">  writer.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_schema</span>()</span><br><span class="line">  <span class="keyword">return</span> Schema(path=ID(unique=<span class="literal">True</span>, stored=<span class="literal">True</span>), content=TEXT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_doc</span>(<span class="params">writer, path</span>):</span><br><span class="line">  fileobj = <span class="built_in">open</span>(path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">  content = fileobj.read()</span><br><span class="line">  fileobj.close()</span><br><span class="line">  writer.add_document(path=path, content=content)</span><br></pre></td></tr></table></figure>

<p>现在，对于一小部分文档，每次都从头开始索引实际上可能已经足够快了。 但是对于大型集合，你会希望脚本只重新索引已更改的文档。</p>
<p>首先，我们需要存储每个文档的最后修改时间，以便我们检查文件是否已更改。 在此示例中，为简单起见，我们将只使用最后修改时间 (mtime)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_schema</span>()</span><br><span class="line">  <span class="keyword">return</span> Schema(path=ID(unique=<span class="literal">True</span>, stored=<span class="literal">True</span>), time=STORED, content=TEXT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_doc</span>(<span class="params">writer, path</span>):</span><br><span class="line">  fileobj = <span class="built_in">open</span>(path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">  content = fileobj.read()</span><br><span class="line">  fileobj.close()</span><br><span class="line">  modtime = os.path.getmtime(path)</span><br><span class="line">  writer.add_document(path=path, content=content, time=modtime)</span><br></pre></td></tr></table></figure>

<p>现在我们可以修改脚本以允许从头开始清理 (<code>clean</code>) 或增量索引：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">index_my_docs</span>(<span class="params">dirname, clean=<span class="literal">False</span></span>):</span><br><span class="line">  <span class="keyword">if</span> clean:</span><br><span class="line">    clean_index(dirname)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    incremental_index(dirname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">incremental_index</span>(<span class="params">dirname</span>)</span><br><span class="line">    ix = index.open_dir(dirname)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 索引中所有 path 的集合</span></span><br><span class="line">    indexed_paths = <span class="built_in">set</span>()</span><br><span class="line">    <span class="comment"># 我们需要重新索引的所有 path 的集合</span></span><br><span class="line">    to_index = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> searcher:</span><br><span class="line">      writer = ix.writer()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 遍历索引中的存储字段</span></span><br><span class="line">      <span class="keyword">for</span> fields <span class="keyword">in</span> searcher.all_stored_fields():</span><br><span class="line">        indexed_path = fields[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">        indexed_paths.add(indexed_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(indexed_path):</span><br><span class="line">          <span class="comment"># 这个文件在索引后被删除了</span></span><br><span class="line">          writer.delete_by_term(<span class="string">&#x27;path&#x27;</span>, indexed_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 检查这个文件在索引后是否被修改过</span></span><br><span class="line">          indexed_time = fields[<span class="string">&#x27;time&#x27;</span>]</span><br><span class="line">          mtime = os.path.getmtime(indexed_path)</span><br><span class="line">          <span class="keyword">if</span> mtime &gt; indexed_time:</span><br><span class="line">            <span class="comment"># 文件发生变化，删除并添加到文件列表中重新索引</span></span><br><span class="line">            writer.delete_by_term(<span class="string">&#x27;path&#x27;</span>, indexed_path)</span><br><span class="line">            to_index.add(indexed_path)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 遍历文件系统中的文件</span></span><br><span class="line">      <span class="comment"># 假设我们有一个函数用于收集索引文档的文件名</span></span><br><span class="line">      <span class="keyword">for</span> path <span class="keyword">in</span> my_docs():</span><br><span class="line">        <span class="keyword">if</span> path <span class="keyword">in</span> to_index <span class="keyword">or</span> path <span class="keyword">not</span> <span class="keyword">in</span> indexed_paths:</span><br><span class="line">          <span class="comment"># 这要么是一个被改变的文件，</span></span><br><span class="line">          <span class="comment"># 要么是一个没有被索引过的新文件。 所以索引它！</span></span><br><span class="line">          add_doc(writer, path)</span><br><span class="line"></span><br><span class="line">      writer.commit()</span><br></pre></td></tr></table></figure>

<p><code>incremental_index</code> 函数：</p>
<ul>
<li>循环遍历当前索引的所有路径。<ul>
<li>如果任何文件不再存在，请从索引中删除相应的文档。</li>
<li>如果该文件仍然存在，但已被修改，则将其添加到要重新索引的路径列表中。</li>
<li>如果文件存在，不管它是否被修改，都将它添加到所有索引路径的列表中。</li>
</ul>
</li>
<li>循环遍历磁盘上文件的所有路径。<ul>
<li>如果路径不在所有索引路径的集合中，则该文件是新文件，我们需要对其进行索引。</li>
<li>如果路径在要重新索引的路径集中，我们需要对其进行索引。</li>
<li>否则，我们可以跳过索引文件。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh <span class="keyword">import</span> writing</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> myindex.writer() <span class="keyword">as</span> mywriter:</span><br><span class="line">    <span class="comment"># 你可以选择在此处向写入器添加文档，例如 mywriter.add_document(...)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 mergetype=CLEAR 清除所有现有段，</span></span><br><span class="line">    <span class="comment"># 因此索引将只包含你添加到此写入器的任何文档</span></span><br><span class="line">    mywriter.mergetype = writing.CLEAR</span><br></pre></td></tr></table></figure>

<p>或者，如果你不使用 <code>writer</code> 作为上下文管理器并直接调用 <code>commit()</code>，请这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mywriter = myindex.writer()</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">mywriter.commit(mergetype=writing.CLEAR)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<br>如果你不需要担心现有的读入器 (readers) ，更有效的方法是简单地删除索引目录的内容并重新开始。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Whoosh/" rel="tag"># Whoosh</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/whoosh/06-%E5%A6%82%E4%BD%95%E6%90%9C%E7%B4%A2/" rel="prev" title="Whoosh 06 - 如何搜索">
                  <i class="fa fa-chevron-left"></i> Whoosh 06 - 如何搜索
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/whoosh/04-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/" rel="next" title="Whoosh 04 - 模式设计">
                  Whoosh 04 - 模式设计 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
